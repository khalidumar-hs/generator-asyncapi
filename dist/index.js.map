{"version":3,"sources":["../src/index.ts","../src/utils/schemas.ts","../src/utils/messages.ts","../src/utils/services.ts","../src/utils/domains.ts","../src/utils/channels.ts","../src/checkLicense.ts","../package.json"],"sourcesContent":["import { AsyncAPIDocumentInterface, MessageInterface, Parser, fromFile, fromURL } from '@asyncapi/parser';\nimport utils from '@eventcatalog/sdk';\nimport { readFile } from 'node:fs/promises';\nimport argv from 'minimist';\nimport yaml from 'js-yaml';\nimport { z } from 'zod';\nimport chalk from 'chalk';\nimport path from 'path';\n\n// AsyncAPI Parsers\nimport { AvroSchemaParser } from '@asyncapi/avro-schema-parser';\n\nimport {\n  defaultMarkdown as generateMarkdownForMessage,\n  getChannelsForMessage,\n  getMessageName,\n  getSummary as getMessageSummary,\n  getSchemaFileName,\n  messageHasSchema,\n} from './utils/messages';\nimport { defaultMarkdown as generateMarkdownForService, getSummary as getServiceSummary } from './utils/services';\nimport { defaultMarkdown as generateMarkdownForDomain } from './utils/domains';\nimport { defaultMarkdown as generateMarkdownForChannel, getChannelProtocols } from './utils/channels';\nimport checkLicense from './checkLicense';\n\nimport { EventType, MessageOperations } from './types';\n\nconst parser = new Parser();\n\n// register avro schema support\nparser.registerSchemaParser(AvroSchemaParser());\nconst cliArgs = argv(process.argv.slice(2));\n\nconst optionsSchema = z.object({\n  licenseKey: z.string().optional(),\n  services: z.array(\n    z.object({\n      id: z.string({ required_error: 'The service id is required. please provide the service id' }),\n      path: z.string({ required_error: 'The service path is required. please provide the path to specification file' }),\n      name: z.string().optional(),\n      version: z.string().optional(),\n    }),\n    { message: 'Please provide correct services configuration' }\n  ),\n  domain: z\n    .object({\n      id: z.string({ required_error: 'The domain id is required. please provide a domain id' }),\n      name: z.string({ required_error: 'The domain name is required. please provide a domain name' }),\n      version: z.string({ required_error: 'The domain version is required. please provide a domain version' }),\n    })\n    .optional(),\n  debug: z.boolean().optional(),\n  parseSchemas: z.boolean().optional(),\n  parseChannels: z.boolean().optional(),\n  saveParsedSpecFile: z.boolean({ invalid_type_error: 'The saveParsedSpecFile is not a boolean in options' }).optional(),\n});\n\ntype Props = z.infer<typeof optionsSchema>;\ntype Domain = z.infer<typeof optionsSchema>['domain'];\ntype Service = z.infer<typeof optionsSchema>['services'][0];\n\nconst validateOptions = (options: Props) => {\n  try {\n    optionsSchema.parse(options);\n  } catch (error: any) {\n    if (error instanceof z.ZodError) throw new Error(JSON.stringify(error.issues, null, 2));\n  }\n};\n\nexport default async (config: any, options: Props) => {\n  if (!process.env.PROJECT_DIR) {\n    process.env.PROJECT_DIR = process.cwd();\n  }\n\n  if (!process.env.PROJECT_DIR) {\n    throw new Error('Please provide catalog url (env variable PROJECT_DIR)');\n  }\n\n  await checkLicense(options.licenseKey);\n\n  const {\n    writeService,\n    writeEvent,\n    writeCommand,\n    writeQuery,\n    getService,\n    versionService,\n    getDomain,\n    writeDomain,\n    addServiceToDomain,\n    getCommand,\n    getEvent,\n    getQuery,\n    versionCommand,\n    versionEvent,\n    versionQuery,\n    addSchemaToCommand,\n    addSchemaToEvent,\n    addSchemaToQuery,\n    addFileToService,\n    versionDomain,\n    getSpecificationFilesForService,\n    writeChannel,\n    getChannel,\n    versionChannel,\n  } = utils(process.env.PROJECT_DIR);\n\n  // Define the message operations mapping with proper types\n  const MESSAGE_OPERATIONS: Record<EventType, MessageOperations> = {\n    event: {\n      write: writeEvent,\n      version: versionEvent,\n      get: getEvent,\n      addSchema: addSchemaToEvent,\n    },\n    command: {\n      write: writeCommand,\n      version: versionCommand,\n      get: getCommand,\n      addSchema: addSchemaToCommand,\n    },\n    query: {\n      write: writeQuery,\n      version: versionQuery,\n      get: getQuery,\n      addSchema: addSchemaToQuery,\n    },\n  };\n\n  // Should the file that is written to the catalog be parsed (https://github.com/asyncapi/parser-js) or as it is?\n  validateOptions(options);\n\n  const { services, saveParsedSpecFile = false, parseSchemas = true, parseChannels = false } = options;\n  // const asyncAPIFiles = Array.isArray(options.path) ? options.path : [options.path];\n  console.log(chalk.green(`Processing ${services.length} AsyncAPI files...`));\n  for (const service of services) {\n    console.log(chalk.gray(`Processing ${service.path}`));\n\n    const { document, diagnostics } = service.path.startsWith('http')\n      ? await fromURL(parser, service.path).parse({\n          parseSchemas,\n        })\n      : await fromFile(parser, service.path).parse({\n          parseSchemas,\n        });\n\n    if (!document) {\n      console.log(chalk.red('Failed to parse AsyncAPI file'));\n      if (options.debug || cliArgs.debug) {\n        console.log(diagnostics);\n      } else {\n        console.log(chalk.red('Run with debug option in the generator to see diagnostics'));\n      }\n      continue;\n    }\n\n    const operations = document.allOperations();\n    const channels = document.allChannels();\n    const documentTags = document.info().tags().all() || [];\n\n    const serviceId = service.id;\n\n    const serviceName = service.name || document.info().title();\n    const version = service.version || document.info().version();\n\n    // What messages does this service send and receive\n    let sends = [];\n    let receives = [];\n\n    let owners = null;\n    let repository = null;\n\n    let serviceSpecifications = {};\n    let serviceSpecificationsFiles = [];\n    let serviceMarkdown = generateMarkdownForService(document);\n\n    // Manage domain\n    if (options.domain) {\n      // Try and get the domain\n      const { id: domainId, name: domainName, version: domainVersion } = options.domain;\n      const domain = await getDomain(options.domain.id, domainVersion || 'latest');\n      const currentDomain = await getDomain(options.domain.id, 'latest');\n\n      console.log(chalk.blue(`\\nProcessing domain: ${domainName} (v${domainVersion})`));\n\n      // Found a domain, but the versions do not match\n      if (currentDomain && currentDomain.version !== domainVersion) {\n        await versionDomain(domainId);\n        console.log(chalk.cyan(` - Versioned previous domain (v${currentDomain.version})`));\n      }\n\n      // Do we need to create a new domain?\n      if (!domain || (domain && domain.version !== domainVersion)) {\n        await writeDomain({\n          id: domainId,\n          name: domainName,\n          version: domainVersion,\n          markdown: generateMarkdownForDomain(document),\n          // services: [{ id: serviceId, version: version }],\n        });\n        console.log(chalk.cyan(` - Domain (v${domainVersion}) created`));\n      }\n\n      if (currentDomain && currentDomain.version === domainVersion) {\n        console.log(chalk.yellow(` - Domain (v${domainVersion}) already exists, skipped creation...`));\n      }\n\n      // Add the service to the domain\n      await addServiceToDomain(domainId, { id: serviceId, version: version }, domainVersion);\n    }\n\n    // Parse channels\n    if (parseChannels) {\n      for (const channel of channels) {\n        const channelAsJSON = channel.json();\n        const channelId = channel.id();\n        const params = channelAsJSON?.parameters || {};\n        const protocols = getChannelProtocols(channel);\n        const channelVersion = channel.extensions().get('x-eventcatalog-channel-version')?.value() || version;\n        let channelMarkdown = generateMarkdownForChannel(document, channel);\n\n        console.log(chalk.blue(`Processing channel: ${channelId} (v${channelVersion})`));\n\n        const paramsForCatalog = Object.keys(params).reduce(\n          (acc, key) => {\n            const param = params[key];\n            acc[key] = {};\n            if (param.enum) acc[key].enum = param.enum;\n            if (param.default) acc[key].default = param.default;\n            if (param.examples) acc[key].examples = param.examples;\n            if (param.description) acc[key].description = param.description;\n            return acc;\n          },\n          {} as Record<string, { enum?: string[]; default?: string; examples?: string[]; description?: string }>\n        );\n\n        const catalogedChannel = await getChannel(channelId, 'latest');\n\n        if (catalogedChannel) {\n          channelMarkdown = catalogedChannel.markdown;\n          if (catalogedChannel.version !== channelVersion) {\n            await versionChannel(channelId);\n            console.log(chalk.cyan(` - Versioned previous channel: ${channelId} (v${channelVersion})`));\n          }\n        }\n\n        await writeChannel(\n          {\n            id: channelId,\n            name: channelAsJSON?.title || channel.id(),\n            markdown: channelMarkdown,\n            version: channelVersion,\n            ...(Object.keys(paramsForCatalog).length > 0 && { parameters: paramsForCatalog }),\n            ...(channel.address() && { address: channel.address() }),\n            ...(channelAsJSON?.summary && { summary: channelAsJSON.summary }),\n            ...(protocols.length > 0 && { protocols }),\n          },\n          { override: true }\n        );\n\n        console.log(chalk.cyan(` - Message ${channelId} (v${version}) created`));\n      }\n    }\n\n    // Find events/commands\n    for (const operation of operations) {\n      for (const message of operation.messages()) {\n        const eventType = (message.extensions().get('x-eventcatalog-message-type')?.value() as EventType) || 'event';\n        const messageVersion = message.extensions().get('x-eventcatalog-message-version')?.value() || version;\n\n        // does this service own or just consume the message?\n        const serviceOwnsMessageContract = isServiceMessageOwner(message);\n        const isReceived = operation.action() === 'receive' || operation.action() === 'subscribe';\n        const isSent = operation.action() === 'send' || operation.action() === 'publish';\n\n        const messageId = message.id().toLowerCase();\n\n        if (eventType !== 'event' && eventType !== 'command' && eventType !== 'query') {\n          throw new Error('Invalid message type');\n        }\n\n        const {\n          write: writeMessage,\n          version: versionMessage,\n          get: getMessage,\n          addSchema: addSchemaToMessage,\n        } = MESSAGE_OPERATIONS[eventType];\n\n        let messageMarkdown = generateMarkdownForMessage(document, message);\n        const badges = message.tags().all() || [];\n\n        console.log(chalk.blue(`Processing message: ${getMessageName(message)} (v${messageVersion})`));\n\n        if (serviceOwnsMessageContract) {\n          // Check if the message already exists in the catalog\n          const catalogedMessage = await getMessage(message.id().toLowerCase(), 'latest');\n\n          if (catalogedMessage) {\n            // persist markdown if it exists\n            messageMarkdown = catalogedMessage.markdown;\n\n            if (catalogedMessage.version !== messageVersion) {\n              // if the version does not match, we need to version the message\n              await versionMessage(messageId);\n              console.log(chalk.cyan(` - Versioned previous message: (v${catalogedMessage.version})`));\n            }\n          }\n\n          const channelsForMessage = parseChannels ? getChannelsForMessage(message, channels, document) : [];\n\n          // Write the message to the catalog\n          await writeMessage(\n            {\n              id: messageId,\n              version: messageVersion,\n              name: getMessageName(message),\n              summary: getMessageSummary(message),\n              markdown: messageMarkdown,\n              badges: badges.map((badge) => ({ content: badge.name(), textColor: 'blue', backgroundColor: 'blue' })),\n              schemaPath: messageHasSchema(message) ? getSchemaFileName(message) : undefined,\n              ...(channelsForMessage.length > 0 && { channels: channelsForMessage }),\n            },\n            {\n              override: true,\n              path: message.id(),\n            }\n          );\n\n          console.log(chalk.cyan(` - Message (v${messageVersion}) created`));\n          // Check if the message has a payload, if it does then document in EventCatalog\n          if (messageHasSchema(message)) {\n            // Get the schema from the original payload if it exists\n            const schema = message.payload()?.extensions()?.get('x-parser-original-payload')?.json() || message.payload()?.json();\n\n            await addSchemaToMessage(\n              messageId,\n              {\n                fileName: getSchemaFileName(message),\n                schema: JSON.stringify(schema, null, 4),\n              },\n              messageVersion\n            );\n            console.log(chalk.cyan(` - Schema added to message (v${messageVersion})`));\n          }\n        } else {\n          // Message is not owned by this service, therefore we don't need to document it\n          console.log(chalk.yellow(` - Skipping external message: ${getMessageName(message)}(v${messageVersion})`));\n        }\n        // Add the message to the correct array\n        if (isSent) sends.push({ id: messageId, version: messageVersion });\n        if (isReceived) receives.push({ id: messageId, version: messageVersion });\n      }\n    }\n\n    // Check if service is already defined... if the versions do not match then create service.\n    const latestServiceInCatalog = await getService(serviceId, 'latest');\n\n    console.log(chalk.blue(`Processing service: ${serviceId} (v${version})`));\n\n    if (latestServiceInCatalog) {\n      serviceMarkdown = latestServiceInCatalog.markdown;\n      owners = latestServiceInCatalog.owners || ([] as any);\n      repository = latestServiceInCatalog.repository || null;\n\n      // Found a service, and versions do not match, we need to version the one already there\n      if (latestServiceInCatalog.version !== version) {\n        await versionService(serviceId);\n        console.log(chalk.cyan(` - Versioned previous service (v${latestServiceInCatalog.version})`));\n      }\n\n      // Match found, persist data\n      if (latestServiceInCatalog.version === version) {\n        // we want to preserve the markdown any any spec files that are already there\n        serviceMarkdown = latestServiceInCatalog.markdown;\n        serviceSpecifications = latestServiceInCatalog.specifications ?? {};\n        sends = latestServiceInCatalog.sends ? [...latestServiceInCatalog.sends, ...sends] : sends;\n        receives = latestServiceInCatalog.receives ? [...latestServiceInCatalog.receives, ...receives] : receives;\n        serviceSpecificationsFiles = await getSpecificationFilesForService(serviceId, version);\n      }\n    }\n\n    const fileName = path.basename(service.path);\n\n    await writeService(\n      {\n        id: serviceId,\n        name: serviceName,\n        version: version,\n        summary: getServiceSummary(document),\n        badges: documentTags.map((tag) => ({ content: tag.name(), textColor: 'blue', backgroundColor: 'blue' })),\n        markdown: serviceMarkdown,\n        sends,\n        receives,\n        schemaPath: fileName || 'asyncapi.yml',\n        specifications: {\n          ...serviceSpecifications,\n          asyncapiPath: fileName || 'asyncapi.yml',\n        },\n        ...(owners && { owners }),\n        ...(repository && { repository }),\n      },\n      {\n        override: true,\n      }\n    );\n\n    // What files need added to the service (speficiation files)\n    const specFiles = [\n      // add any previous spec files to the list\n      ...serviceSpecificationsFiles,\n      {\n        content: saveParsedSpecFile ? getParsedSpecFile(service, document) : await getRawSpecFile(service),\n        fileName: path.basename(service.path) || 'asyncapi.yml',\n      },\n    ];\n\n    for (const specFile of specFiles) {\n      await addFileToService(\n        serviceId,\n        {\n          fileName: specFile.fileName,\n          content: specFile.content,\n        },\n        version\n      );\n    }\n\n    console.log(chalk.cyan(` - Service (v${version}) created`));\n\n    console.log(chalk.green(`\\nFinished generating event catalog for AsyncAPI ${serviceId} (v${version})`));\n  }\n};\n\nconst getParsedSpecFile = (service: Service, document: AsyncAPIDocumentInterface) => {\n  const isSpecFileJSON = service.path.endsWith('.json');\n  return isSpecFileJSON\n    ? JSON.stringify(document.meta().asyncapi.parsed, null, 4)\n    : yaml.dump(document.meta().asyncapi.parsed, { noRefs: true });\n};\n\nconst getRawSpecFile = async (service: Service) => {\n  if (service.path.startsWith('http')) {\n    try {\n      const response = await fetch(service.path);\n      return response.text();\n    } catch (error) {\n      console.log(chalk.red(`\\nFailed to request AsyncAPI file from ${service.path}`));\n      return '';\n    }\n  } else {\n    return await readFile(service.path, 'utf8');\n  }\n};\n/**\n * Is the AsyncAPI specification (service) the owner of the message?\n * This is determined by the 'x-eventcatalog-role' extension in the message\n *\n * @param message\n * @returns boolean\n *\n * default is provider (AsyncAPI file / service owns the message)\n */\nconst isServiceMessageOwner = (message: MessageInterface): boolean => {\n  const value = message.extensions().get('x-eventcatalog-role')?.value() || 'provider';\n  return value === 'provider';\n};\n","export const getFileExtentionFromSchemaFormat = (format: string | undefined = '') => {\n  if (format.includes('avro')) return 'avsc';\n  if (format.includes('yml')) return 'yml';\n  if (format.includes('json')) return 'json';\n  if (format.includes('openapi')) return 'openapi';\n  if (format.includes('protobuf')) return 'protobuf';\n  if (format.includes('yaml')) return 'yaml';\n\n  return 'json';\n};\n","import {\n  MessageInterface,\n  AsyncAPIDocumentInterface,\n  ChannelInterface,\n  ChannelsInterface,\n  MessagesInterface,\n} from '@asyncapi/parser';\nimport { getFileExtentionFromSchemaFormat } from './schemas';\n\nexport const defaultMarkdown = (_document: AsyncAPIDocumentInterface, message: MessageInterface) => {\n  return `\n## Architecture\n<NodeGraph />\n\n${\n  messageHasSchema(message) && messageIsJSON(message)\n    ? `\n## Schema\n<SchemaViewer file=\"${getSchemaFileName(message)}\" title=\"Message Schema\" maxHeight=\"500\" />\n`\n    : ''\n}\n${\n  messageHasSchema(message) && !messageIsJSON(message)\n    ? `\n## Schema\n<Schema file=\"${getSchemaFileName(message)}\" title=\"Message Schema\" maxHeight=\"500\" />\n`\n    : ''\n}\n\n${\n  message.externalDocs()\n    ? `\n## External documentation\n- [${message.externalDocs()?.description()}](${message.externalDocs()?.url()})\n`\n    : ''\n}\n\n`;\n};\n\nexport const getSummary = (message: MessageInterface) => {\n  const messageSummary = message.hasSummary() ? message.summary() : '';\n  const messageDescription = message.hasDescription() ? message.description() : '';\n\n  let eventCatalogMessageSummary = messageSummary;\n\n  if (!eventCatalogMessageSummary) {\n    eventCatalogMessageSummary = messageDescription && messageDescription.length < 150 ? messageDescription : '';\n  }\n\n  return eventCatalogMessageSummary;\n};\n\nexport const messageHasSchema = (message: MessageInterface) => {\n  return message.hasPayload() && message.schemaFormat();\n};\n\nexport const messageIsJSON = (message: MessageInterface) => {\n  const fileName = getSchemaFileName(message);\n  return fileName.endsWith('.json');\n};\n\nexport const getSchemaFileName = (message: MessageInterface) => {\n  const extension = getFileExtentionFromSchemaFormat(message.schemaFormat());\n  return `schema.${extension}`;\n};\n\nexport const getMessageName = (message: MessageInterface) => {\n  return message.hasTitle() && message.title() ? (message.title() as string) : message.id();\n};\n\nexport const getChannelsForMessage = (\n  message: MessageInterface,\n  channels: ChannelsInterface,\n  document: AsyncAPIDocumentInterface\n): { id: string; version: string }[] => {\n  let channelsForMessage: ChannelInterface[] = [];\n  const globalVersion = document.info().version();\n\n  // Go through all channels and link messages they document\n  for (const channel of channels) {\n    for (const channelMessage of channel.messages() as MessagesInterface) {\n      if (channelMessage.id() === message.id()) {\n        channelsForMessage.push(channel);\n      }\n    }\n  }\n\n  // You can also document a message directly to a channel, add them too\n  for (const messageChannel of message.channels()) {\n    channelsForMessage.push(messageChannel);\n  }\n\n  // Make them unique, as there may be overlapping channels\n  const uniqueChannels = channelsForMessage.filter(\n    (channel, index, self) => index === self.findIndex((t) => t.id() === channel.id())\n  );\n\n  return uniqueChannels.map((channel) => {\n    const channelVersion = channel.extensions().get('x-eventcatalog-channel-version')?.value() || globalVersion;\n    return {\n      id: channel.id(),\n      version: channelVersion,\n    };\n  });\n};\n","import { AsyncAPIDocumentInterface } from '@asyncapi/parser';\n\nexport const defaultMarkdown = (document: AsyncAPIDocumentInterface) => {\n  return `\n\n${document.info().hasDescription() ? `${document.info().description()}` : ''}  \n\n## Architecture diagram\n<NodeGraph />\n\n${\n  document.info().externalDocs()\n    ? `\n## External documentation\n- [${document.info().externalDocs()?.description()}](${document.info().externalDocs()?.url()})\n`\n    : ''\n}\n`;\n};\n\nexport const getSummary = (document: AsyncAPIDocumentInterface) => {\n  const summary = document.info().hasDescription() ? document.info().description() : '';\n  return summary && summary.length < 150 ? summary : '';\n};\n","import { AsyncAPIDocumentInterface } from '@asyncapi/parser';\n\nexport const defaultMarkdown = (document: AsyncAPIDocumentInterface) => {\n  return `\n\n## Architecture diagram\n<NodeGraph />\n\n`;\n};\n","import { AsyncAPIDocumentInterface, ChannelInterface } from '@asyncapi/parser';\n\nexport const getChannelProtocols = (channel: ChannelInterface): string[] => {\n  const protocols = [];\n\n  const bindings = channel.bindings();\n  for (const binding of bindings) {\n    protocols.push(binding.protocol());\n  }\n\n  return protocols;\n};\n\nexport const defaultMarkdown = (_document: AsyncAPIDocumentInterface, channel: ChannelInterface) => {\n  return `\n  ${\n    channel.hasDescription()\n      ? `\n  ## Overview\n  ${channel.description()}\n  `\n      : ''\n  }\n\n  <ChannelInformation />\n\n  ${\n    channel.json()?.externalDocs\n      ? `\n  ## External documentation\n  - [${channel.json()?.externalDocs?.description}](${channel.json()?.externalDocs?.url})\n  `\n      : ''\n  }\n  \n  `;\n};\n","import chalk from 'chalk';\nimport pkg from '../package.json';\n\ntype LicenseResponse = {\n  is_trial: boolean;\n  plugin: string;\n  state: string;\n};\n\nexport default async (licenseKey?: string) => {\n  const LICENSE_KEY = process.env.EVENTCATALOG_LICENSE_KEY_ASYNCAPI || licenseKey || null;\n\n  if (!LICENSE_KEY) {\n    console.log(chalk.bgRed(`\\nThis plugin requires a license key to use`));\n    console.log(chalk.redBright(`\\nVisit https://eventcatalog.cloud/ to get a 14 day trial or purchase a license`));\n    process.exit(1);\n  }\n\n  // Verify the license key\n  const response = await fetch('https://api.eventcatalog.cloud/functions/v1/license', {\n    method: 'POST',\n    headers: {\n      Authorization: `Bearer ${LICENSE_KEY}`,\n      'Content-Type': 'application/json',\n    },\n  });\n\n  if (response.status !== 200) {\n    console.log(chalk.bgRed(`\\nInvalid license key`));\n    console.log(chalk.redBright('Please check your plugin license key or purchase a license at https://eventcatalog.cloud/'));\n    process.exit(1);\n  }\n\n  if (response.status === 200) {\n    const data = (await response.json()) as LicenseResponse;\n\n    if (pkg.name !== data.plugin) {\n      console.log(chalk.bgRed(`\\nInvalid license key for this plugin`));\n      console.log(chalk.redBright('Please check your plugin license key or purchase a license at https://eventcatalog.cloud/'));\n      process.exit(1);\n    }\n\n    if (data.is_trial) {\n      console.log(chalk.bgBlue(`\\nYou are using a trial license for this plugin`));\n    }\n  }\n\n  return Promise.resolve();\n};\n","{\n  \"name\": \"@khalidumar-hs/generator-asyncapi\",\n  \"version\": \"2.7.5\",\n  \"description\": \"AsyncAPI generator for EventCatalog\",\n  \"scripts\": {\n    \"build\": \"tsup\",\n    \"test\": \"vitest\",\n    \"format\": \"prettier --write .\",\n    \"format:diff\": \"prettier --list-different .\",\n    \"changeset\": \"changeset\",\n    \"release\": \"changeset publish\"\n  },\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"keywords\": [],\n  \"author\": \"khalidumar-hs\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"@changesets/cli\": \"^2.27.9\",\n    \"@types/fs-extra\": \"^11.0.4\",\n    \"@types/js-yaml\": \"^4.0.9\",\n    \"@types/lodash\": \"^4.17.7\",\n    \"@types/minimist\": \"^1.2.5\",\n    \"@types/node\": \"^20.16.1\",\n    \"prettier\": \"^3.3.3\",\n    \"tsup\": \"^8.1.0\",\n    \"typescript\": \"^5.5.3\",\n    \"vitest\": \"^2.0.2\"\n  },\n  \"files\": [\n    \"dist\",\n    \"package.json\"\n  ],\n  \"main\": \"./dist/index.js\",\n  \"module\": \"./dist/index.mjs\",\n  \"types\": \"./dist/index.d.ts\",\n  \"dependencies\": {\n    \"@asyncapi/avro-schema-parser\": \"^3.0.24\",\n    \"@asyncapi/parser\": \"^3.3.0\",\n    \"@eventcatalog/sdk\": \"^1.4.4\",\n    \"chalk\": \"^4\",\n    \"fs-extra\": \"^11.2.0\",\n    \"glob\": \"^11.0.0\",\n    \"gray-matter\": \"^4.0.3\",\n    \"js-yaml\": \"^4.1.0\",\n    \"lodash\": \"^4.17.21\",\n    \"minimist\": \"^1.2.8\",\n    \"slugify\": \"^1.6.6\",\n    \"zod\": \"^3.23.8\"\n  },\n  \"directories\": {\n    \"example\": \"examples\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/khalidumar-hs/generator-asyncapi.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/khalidumar-hs/generator-asyncapi/issues\"\n  },\n  \"homepage\": \"https://github.com/khalidumar-hs/generator-asyncapi#readme\"\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBAAuF;AACvF,iBAAkB;AAClB,sBAAyB;AACzB,sBAAiB;AACjB,qBAAiB;AACjB,iBAAkB;AAClB,IAAAA,gBAAkB;AAClB,kBAAiB;AAGjB,gCAAiC;;;ACV1B,IAAM,mCAAmC,CAAC,SAA6B,OAAO;AACnF,MAAI,OAAO,SAAS,MAAM,EAAG,QAAO;AACpC,MAAI,OAAO,SAAS,KAAK,EAAG,QAAO;AACnC,MAAI,OAAO,SAAS,MAAM,EAAG,QAAO;AACpC,MAAI,OAAO,SAAS,SAAS,EAAG,QAAO;AACvC,MAAI,OAAO,SAAS,UAAU,EAAG,QAAO;AACxC,MAAI,OAAO,SAAS,MAAM,EAAG,QAAO;AAEpC,SAAO;AACT;;;ACAO,IAAM,kBAAkB,CAAC,WAAsC,YAA8B;AAClG,SAAO;AAAA;AAAA;AAAA;AAAA,EAKP,iBAAiB,OAAO,KAAK,cAAc,OAAO,IAC9C;AAAA;AAAA,sBAEgB,kBAAkB,OAAO,CAAC;AAAA,IAE1C,EACN;AAAA,EAEE,iBAAiB,OAAO,KAAK,CAAC,cAAc,OAAO,IAC/C;AAAA;AAAA,gBAEU,kBAAkB,OAAO,CAAC;AAAA,IAEpC,EACN;AAAA;AAAA,EAGE,QAAQ,aAAa,IACjB;AAAA;AAAA,KAED,QAAQ,aAAa,GAAG,YAAY,CAAC,KAAK,QAAQ,aAAa,GAAG,IAAI,CAAC;AAAA,IAEtE,EACN;AAAA;AAAA;AAGA;AAEO,IAAM,aAAa,CAAC,YAA8B;AACvD,QAAM,iBAAiB,QAAQ,WAAW,IAAI,QAAQ,QAAQ,IAAI;AAClE,QAAM,qBAAqB,QAAQ,eAAe,IAAI,QAAQ,YAAY,IAAI;AAE9E,MAAI,6BAA6B;AAEjC,MAAI,CAAC,4BAA4B;AAC/B,iCAA6B,sBAAsB,mBAAmB,SAAS,MAAM,qBAAqB;AAAA,EAC5G;AAEA,SAAO;AACT;AAEO,IAAM,mBAAmB,CAAC,YAA8B;AAC7D,SAAO,QAAQ,WAAW,KAAK,QAAQ,aAAa;AACtD;AAEO,IAAM,gBAAgB,CAAC,YAA8B;AAC1D,QAAM,WAAW,kBAAkB,OAAO;AAC1C,SAAO,SAAS,SAAS,OAAO;AAClC;AAEO,IAAM,oBAAoB,CAAC,YAA8B;AAC9D,QAAM,YAAY,iCAAiC,QAAQ,aAAa,CAAC;AACzE,SAAO,UAAU,SAAS;AAC5B;AAEO,IAAM,iBAAiB,CAAC,YAA8B;AAC3D,SAAO,QAAQ,SAAS,KAAK,QAAQ,MAAM,IAAK,QAAQ,MAAM,IAAe,QAAQ,GAAG;AAC1F;AAEO,IAAM,wBAAwB,CACnC,SACA,UACA,aACsC;AACtC,MAAI,qBAAyC,CAAC;AAC9C,QAAM,gBAAgB,SAAS,KAAK,EAAE,QAAQ;AAG9C,aAAW,WAAW,UAAU;AAC9B,eAAW,kBAAkB,QAAQ,SAAS,GAAwB;AACpE,UAAI,eAAe,GAAG,MAAM,QAAQ,GAAG,GAAG;AACxC,2BAAmB,KAAK,OAAO;AAAA,MACjC;AAAA,IACF;AAAA,EACF;AAGA,aAAW,kBAAkB,QAAQ,SAAS,GAAG;AAC/C,uBAAmB,KAAK,cAAc;AAAA,EACxC;AAGA,QAAM,iBAAiB,mBAAmB;AAAA,IACxC,CAAC,SAAS,OAAO,SAAS,UAAU,KAAK,UAAU,CAAC,MAAM,EAAE,GAAG,MAAM,QAAQ,GAAG,CAAC;AAAA,EACnF;AAEA,SAAO,eAAe,IAAI,CAAC,YAAY;AACrC,UAAM,iBAAiB,QAAQ,WAAW,EAAE,IAAI,gCAAgC,GAAG,MAAM,KAAK;AAC9F,WAAO;AAAA,MACL,IAAI,QAAQ,GAAG;AAAA,MACf,SAAS;AAAA,IACX;AAAA,EACF,CAAC;AACH;;;AC1GO,IAAMC,mBAAkB,CAAC,aAAwC;AACtE,SAAO;AAAA;AAAA,EAEP,SAAS,KAAK,EAAE,eAAe,IAAI,GAAG,SAAS,KAAK,EAAE,YAAY,CAAC,KAAK,EAAE;AAAA;AAAA;AAAA;AAAA;AAAA,EAM1E,SAAS,KAAK,EAAE,aAAa,IACzB;AAAA;AAAA,KAED,SAAS,KAAK,EAAE,aAAa,GAAG,YAAY,CAAC,KAAK,SAAS,KAAK,EAAE,aAAa,GAAG,IAAI,CAAC;AAAA,IAEtF,EACN;AAAA;AAEA;AAEO,IAAMC,cAAa,CAAC,aAAwC;AACjE,QAAM,UAAU,SAAS,KAAK,EAAE,eAAe,IAAI,SAAS,KAAK,EAAE,YAAY,IAAI;AACnF,SAAO,WAAW,QAAQ,SAAS,MAAM,UAAU;AACrD;;;ACtBO,IAAMC,mBAAkB,CAAC,aAAwC;AACtE,SAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAMT;;;ACPO,IAAM,sBAAsB,CAAC,YAAwC;AAC1E,QAAM,YAAY,CAAC;AAEnB,QAAM,WAAW,QAAQ,SAAS;AAClC,aAAW,WAAW,UAAU;AAC9B,cAAU,KAAK,QAAQ,SAAS,CAAC;AAAA,EACnC;AAEA,SAAO;AACT;AAEO,IAAMC,mBAAkB,CAAC,WAAsC,YAA8B;AAClG,SAAO;AAAA,IAEL,QAAQ,eAAe,IACnB;AAAA;AAAA,IAEJ,QAAQ,YAAY,CAAC;AAAA,MAEjB,EACN;AAAA;AAAA;AAAA;AAAA,IAKE,QAAQ,KAAK,GAAG,eACZ;AAAA;AAAA,OAED,QAAQ,KAAK,GAAG,cAAc,WAAW,KAAK,QAAQ,KAAK,GAAG,cAAc,GAAG;AAAA,MAE9E,EACN;AAAA;AAAA;AAGF;;;ACpCA,mBAAkB;;;ACAlB;AAAA,EACE,MAAQ;AAAA,EACR,SAAW;AAAA,EACX,aAAe;AAAA,EACf,SAAW;AAAA,IACT,OAAS;AAAA,IACT,MAAQ;AAAA,IACR,QAAU;AAAA,IACV,eAAe;AAAA,IACf,WAAa;AAAA,IACb,SAAW;AAAA,EACb;AAAA,EACA,eAAiB;AAAA,IACf,QAAU;AAAA,EACZ;AAAA,EACA,UAAY,CAAC;AAAA,EACb,QAAU;AAAA,EACV,SAAW;AAAA,EACX,iBAAmB;AAAA,IACjB,mBAAmB;AAAA,IACnB,mBAAmB;AAAA,IACnB,kBAAkB;AAAA,IAClB,iBAAiB;AAAA,IACjB,mBAAmB;AAAA,IACnB,eAAe;AAAA,IACf,UAAY;AAAA,IACZ,MAAQ;AAAA,IACR,YAAc;AAAA,IACd,QAAU;AAAA,EACZ;AAAA,EACA,OAAS;AAAA,IACP;AAAA,IACA;AAAA,EACF;AAAA,EACA,MAAQ;AAAA,EACR,QAAU;AAAA,EACV,OAAS;AAAA,EACT,cAAgB;AAAA,IACd,gCAAgC;AAAA,IAChC,oBAAoB;AAAA,IACpB,qBAAqB;AAAA,IACrB,OAAS;AAAA,IACT,YAAY;AAAA,IACZ,MAAQ;AAAA,IACR,eAAe;AAAA,IACf,WAAW;AAAA,IACX,QAAU;AAAA,IACV,UAAY;AAAA,IACZ,SAAW;AAAA,IACX,KAAO;AAAA,EACT;AAAA,EACA,aAAe;AAAA,IACb,SAAW;AAAA,EACb;AAAA,EACA,YAAc;AAAA,IACZ,MAAQ;AAAA,IACR,KAAO;AAAA,EACT;AAAA,EACA,MAAQ;AAAA,IACN,KAAO;AAAA,EACT;AAAA,EACA,UAAY;AACd;;;ADrDA,IAAO,uBAAQ,OAAO,eAAwB;AAC5C,QAAM,cAAc,QAAQ,IAAI,qCAAqC,cAAc;AAEnF,MAAI,CAAC,aAAa;AAChB,YAAQ,IAAI,aAAAC,QAAM,MAAM;AAAA,0CAA6C,CAAC;AACtE,YAAQ,IAAI,aAAAA,QAAM,UAAU;AAAA,8EAAiF,CAAC;AAC9G,YAAQ,KAAK,CAAC;AAAA,EAChB;AAGA,QAAM,WAAW,MAAM,MAAM,uDAAuD;AAAA,IAClF,QAAQ;AAAA,IACR,SAAS;AAAA,MACP,eAAe,UAAU,WAAW;AAAA,MACpC,gBAAgB;AAAA,IAClB;AAAA,EACF,CAAC;AAED,MAAI,SAAS,WAAW,KAAK;AAC3B,YAAQ,IAAI,aAAAA,QAAM,MAAM;AAAA,oBAAuB,CAAC;AAChD,YAAQ,IAAI,aAAAA,QAAM,UAAU,2FAA2F,CAAC;AACxH,YAAQ,KAAK,CAAC;AAAA,EAChB;AAEA,MAAI,SAAS,WAAW,KAAK;AAC3B,UAAM,OAAQ,MAAM,SAAS,KAAK;AAElC,QAAI,gBAAI,SAAS,KAAK,QAAQ;AAC5B,cAAQ,IAAI,aAAAA,QAAM,MAAM;AAAA,oCAAuC,CAAC;AAChE,cAAQ,IAAI,aAAAA,QAAM,UAAU,2FAA2F,CAAC;AACxH,cAAQ,KAAK,CAAC;AAAA,IAChB;AAEA,QAAI,KAAK,UAAU;AACjB,cAAQ,IAAI,aAAAA,QAAM,OAAO;AAAA,8CAAiD,CAAC;AAAA,IAC7E;AAAA,EACF;AAEA,SAAO,QAAQ,QAAQ;AACzB;;;ANrBA,IAAM,SAAS,IAAI,qBAAO;AAG1B,OAAO,yBAAqB,4CAAiB,CAAC;AAC9C,IAAM,cAAU,gBAAAC,SAAK,QAAQ,KAAK,MAAM,CAAC,CAAC;AAE1C,IAAM,gBAAgB,aAAE,OAAO;AAAA,EAC7B,YAAY,aAAE,OAAO,EAAE,SAAS;AAAA,EAChC,UAAU,aAAE;AAAA,IACV,aAAE,OAAO;AAAA,MACP,IAAI,aAAE,OAAO,EAAE,gBAAgB,4DAA4D,CAAC;AAAA,MAC5F,MAAM,aAAE,OAAO,EAAE,gBAAgB,8EAA8E,CAAC;AAAA,MAChH,MAAM,aAAE,OAAO,EAAE,SAAS;AAAA,MAC1B,SAAS,aAAE,OAAO,EAAE,SAAS;AAAA,IAC/B,CAAC;AAAA,IACD,EAAE,SAAS,gDAAgD;AAAA,EAC7D;AAAA,EACA,QAAQ,aACL,OAAO;AAAA,IACN,IAAI,aAAE,OAAO,EAAE,gBAAgB,wDAAwD,CAAC;AAAA,IACxF,MAAM,aAAE,OAAO,EAAE,gBAAgB,4DAA4D,CAAC;AAAA,IAC9F,SAAS,aAAE,OAAO,EAAE,gBAAgB,kEAAkE,CAAC;AAAA,EACzG,CAAC,EACA,SAAS;AAAA,EACZ,OAAO,aAAE,QAAQ,EAAE,SAAS;AAAA,EAC5B,cAAc,aAAE,QAAQ,EAAE,SAAS;AAAA,EACnC,eAAe,aAAE,QAAQ,EAAE,SAAS;AAAA,EACpC,oBAAoB,aAAE,QAAQ,EAAE,oBAAoB,qDAAqD,CAAC,EAAE,SAAS;AACvH,CAAC;AAMD,IAAM,kBAAkB,CAAC,YAAmB;AAC1C,MAAI;AACF,kBAAc,MAAM,OAAO;AAAA,EAC7B,SAAS,OAAY;AACnB,QAAI,iBAAiB,aAAE,SAAU,OAAM,IAAI,MAAM,KAAK,UAAU,MAAM,QAAQ,MAAM,CAAC,CAAC;AAAA,EACxF;AACF;AAEA,IAAO,gBAAQ,OAAO,QAAa,YAAmB;AACpD,MAAI,CAAC,QAAQ,IAAI,aAAa;AAC5B,YAAQ,IAAI,cAAc,QAAQ,IAAI;AAAA,EACxC;AAEA,MAAI,CAAC,QAAQ,IAAI,aAAa;AAC5B,UAAM,IAAI,MAAM,uDAAuD;AAAA,EACzE;AAEA,QAAM,qBAAa,QAAQ,UAAU;AAErC,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,QAAI,WAAAC,SAAM,QAAQ,IAAI,WAAW;AAGjC,QAAM,qBAA2D;AAAA,IAC/D,OAAO;AAAA,MACL,OAAO;AAAA,MACP,SAAS;AAAA,MACT,KAAK;AAAA,MACL,WAAW;AAAA,IACb;AAAA,IACA,SAAS;AAAA,MACP,OAAO;AAAA,MACP,SAAS;AAAA,MACT,KAAK;AAAA,MACL,WAAW;AAAA,IACb;AAAA,IACA,OAAO;AAAA,MACL,OAAO;AAAA,MACP,SAAS;AAAA,MACT,KAAK;AAAA,MACL,WAAW;AAAA,IACb;AAAA,EACF;AAGA,kBAAgB,OAAO;AAEvB,QAAM,EAAE,UAAU,qBAAqB,OAAO,eAAe,MAAM,gBAAgB,MAAM,IAAI;AAE7F,UAAQ,IAAI,cAAAC,QAAM,MAAM,cAAc,SAAS,MAAM,oBAAoB,CAAC;AAC1E,aAAW,WAAW,UAAU;AAC9B,YAAQ,IAAI,cAAAA,QAAM,KAAK,cAAc,QAAQ,IAAI,EAAE,CAAC;AAEpD,UAAM,EAAE,UAAU,YAAY,IAAI,QAAQ,KAAK,WAAW,MAAM,IAC5D,UAAM,uBAAQ,QAAQ,QAAQ,IAAI,EAAE,MAAM;AAAA,MACxC;AAAA,IACF,CAAC,IACD,UAAM,wBAAS,QAAQ,QAAQ,IAAI,EAAE,MAAM;AAAA,MACzC;AAAA,IACF,CAAC;AAEL,QAAI,CAAC,UAAU;AACb,cAAQ,IAAI,cAAAA,QAAM,IAAI,+BAA+B,CAAC;AACtD,UAAI,QAAQ,SAAS,QAAQ,OAAO;AAClC,gBAAQ,IAAI,WAAW;AAAA,MACzB,OAAO;AACL,gBAAQ,IAAI,cAAAA,QAAM,IAAI,2DAA2D,CAAC;AAAA,MACpF;AACA;AAAA,IACF;AAEA,UAAM,aAAa,SAAS,cAAc;AAC1C,UAAM,WAAW,SAAS,YAAY;AACtC,UAAM,eAAe,SAAS,KAAK,EAAE,KAAK,EAAE,IAAI,KAAK,CAAC;AAEtD,UAAM,YAAY,QAAQ;AAE1B,UAAM,cAAc,QAAQ,QAAQ,SAAS,KAAK,EAAE,MAAM;AAC1D,UAAM,UAAU,QAAQ,WAAW,SAAS,KAAK,EAAE,QAAQ;AAG3D,QAAI,QAAQ,CAAC;AACb,QAAI,WAAW,CAAC;AAEhB,QAAI,SAAS;AACb,QAAI,aAAa;AAEjB,QAAI,wBAAwB,CAAC;AAC7B,QAAI,6BAA6B,CAAC;AAClC,QAAI,kBAAkBC,iBAA2B,QAAQ;AAGzD,QAAI,QAAQ,QAAQ;AAElB,YAAM,EAAE,IAAI,UAAU,MAAM,YAAY,SAAS,cAAc,IAAI,QAAQ;AAC3E,YAAM,SAAS,MAAM,UAAU,QAAQ,OAAO,IAAI,iBAAiB,QAAQ;AAC3E,YAAM,gBAAgB,MAAM,UAAU,QAAQ,OAAO,IAAI,QAAQ;AAEjE,cAAQ,IAAI,cAAAD,QAAM,KAAK;AAAA,qBAAwB,UAAU,MAAM,aAAa,GAAG,CAAC;AAGhF,UAAI,iBAAiB,cAAc,YAAY,eAAe;AAC5D,cAAM,cAAc,QAAQ;AAC5B,gBAAQ,IAAI,cAAAA,QAAM,KAAK,kCAAkC,cAAc,OAAO,GAAG,CAAC;AAAA,MACpF;AAGA,UAAI,CAAC,UAAW,UAAU,OAAO,YAAY,eAAgB;AAC3D,cAAM,YAAY;AAAA,UAChB,IAAI;AAAA,UACJ,MAAM;AAAA,UACN,SAAS;AAAA,UACT,UAAUC,iBAA0B,QAAQ;AAAA;AAAA,QAE9C,CAAC;AACD,gBAAQ,IAAI,cAAAD,QAAM,KAAK,eAAe,aAAa,WAAW,CAAC;AAAA,MACjE;AAEA,UAAI,iBAAiB,cAAc,YAAY,eAAe;AAC5D,gBAAQ,IAAI,cAAAA,QAAM,OAAO,eAAe,aAAa,uCAAuC,CAAC;AAAA,MAC/F;AAGA,YAAM,mBAAmB,UAAU,EAAE,IAAI,WAAW,QAAiB,GAAG,aAAa;AAAA,IACvF;AAGA,QAAI,eAAe;AACjB,iBAAW,WAAW,UAAU;AAC9B,cAAM,gBAAgB,QAAQ,KAAK;AACnC,cAAM,YAAY,QAAQ,GAAG;AAC7B,cAAM,SAAS,eAAe,cAAc,CAAC;AAC7C,cAAM,YAAY,oBAAoB,OAAO;AAC7C,cAAM,iBAAiB,QAAQ,WAAW,EAAE,IAAI,gCAAgC,GAAG,MAAM,KAAK;AAC9F,YAAI,kBAAkBC,iBAA2B,UAAU,OAAO;AAElE,gBAAQ,IAAI,cAAAD,QAAM,KAAK,uBAAuB,SAAS,MAAM,cAAc,GAAG,CAAC;AAE/E,cAAM,mBAAmB,OAAO,KAAK,MAAM,EAAE;AAAA,UAC3C,CAAC,KAAK,QAAQ;AACZ,kBAAM,QAAQ,OAAO,GAAG;AACxB,gBAAI,GAAG,IAAI,CAAC;AACZ,gBAAI,MAAM,KAAM,KAAI,GAAG,EAAE,OAAO,MAAM;AACtC,gBAAI,MAAM,QAAS,KAAI,GAAG,EAAE,UAAU,MAAM;AAC5C,gBAAI,MAAM,SAAU,KAAI,GAAG,EAAE,WAAW,MAAM;AAC9C,gBAAI,MAAM,YAAa,KAAI,GAAG,EAAE,cAAc,MAAM;AACpD,mBAAO;AAAA,UACT;AAAA,UACA,CAAC;AAAA,QACH;AAEA,cAAM,mBAAmB,MAAM,WAAW,WAAW,QAAQ;AAE7D,YAAI,kBAAkB;AACpB,4BAAkB,iBAAiB;AACnC,cAAI,iBAAiB,YAAY,gBAAgB;AAC/C,kBAAM,eAAe,SAAS;AAC9B,oBAAQ,IAAI,cAAAA,QAAM,KAAK,kCAAkC,SAAS,MAAM,cAAc,GAAG,CAAC;AAAA,UAC5F;AAAA,QACF;AAEA,cAAM;AAAA,UACJ;AAAA,YACE,IAAI;AAAA,YACJ,MAAM,eAAe,SAAS,QAAQ,GAAG;AAAA,YACzC,UAAU;AAAA,YACV,SAAS;AAAA,YACT,GAAI,OAAO,KAAK,gBAAgB,EAAE,SAAS,KAAK,EAAE,YAAY,iBAAiB;AAAA,YAC/E,GAAI,QAAQ,QAAQ,KAAK,EAAE,SAAS,QAAQ,QAAQ,EAAE;AAAA,YACtD,GAAI,eAAe,WAAW,EAAE,SAAS,cAAc,QAAQ;AAAA,YAC/D,GAAI,UAAU,SAAS,KAAK,EAAE,UAAU;AAAA,UAC1C;AAAA,UACA,EAAE,UAAU,KAAK;AAAA,QACnB;AAEA,gBAAQ,IAAI,cAAAA,QAAM,KAAK,cAAc,SAAS,MAAM,OAAO,WAAW,CAAC;AAAA,MACzE;AAAA,IACF;AAGA,eAAW,aAAa,YAAY;AAClC,iBAAW,WAAW,UAAU,SAAS,GAAG;AAC1C,cAAM,YAAa,QAAQ,WAAW,EAAE,IAAI,6BAA6B,GAAG,MAAM,KAAmB;AACrG,cAAM,iBAAiB,QAAQ,WAAW,EAAE,IAAI,gCAAgC,GAAG,MAAM,KAAK;AAG9F,cAAM,6BAA6B,sBAAsB,OAAO;AAChE,cAAM,aAAa,UAAU,OAAO,MAAM,aAAa,UAAU,OAAO,MAAM;AAC9E,cAAM,SAAS,UAAU,OAAO,MAAM,UAAU,UAAU,OAAO,MAAM;AAEvE,cAAM,YAAY,QAAQ,GAAG,EAAE,YAAY;AAE3C,YAAI,cAAc,WAAW,cAAc,aAAa,cAAc,SAAS;AAC7E,gBAAM,IAAI,MAAM,sBAAsB;AAAA,QACxC;AAEA,cAAM;AAAA,UACJ,OAAO;AAAA,UACP,SAAS;AAAA,UACT,KAAK;AAAA,UACL,WAAW;AAAA,QACb,IAAI,mBAAmB,SAAS;AAEhC,YAAI,kBAAkB,gBAA2B,UAAU,OAAO;AAClE,cAAM,SAAS,QAAQ,KAAK,EAAE,IAAI,KAAK,CAAC;AAExC,gBAAQ,IAAI,cAAAA,QAAM,KAAK,uBAAuB,eAAe,OAAO,CAAC,MAAM,cAAc,GAAG,CAAC;AAE7F,YAAI,4BAA4B;AAE9B,gBAAM,mBAAmB,MAAM,WAAW,QAAQ,GAAG,EAAE,YAAY,GAAG,QAAQ;AAE9E,cAAI,kBAAkB;AAEpB,8BAAkB,iBAAiB;AAEnC,gBAAI,iBAAiB,YAAY,gBAAgB;AAE/C,oBAAM,eAAe,SAAS;AAC9B,sBAAQ,IAAI,cAAAA,QAAM,KAAK,oCAAoC,iBAAiB,OAAO,GAAG,CAAC;AAAA,YACzF;AAAA,UACF;AAEA,gBAAM,qBAAqB,gBAAgB,sBAAsB,SAAS,UAAU,QAAQ,IAAI,CAAC;AAGjG,gBAAM;AAAA,YACJ;AAAA,cACE,IAAI;AAAA,cACJ,SAAS;AAAA,cACT,MAAM,eAAe,OAAO;AAAA,cAC5B,SAAS,WAAkB,OAAO;AAAA,cAClC,UAAU;AAAA,cACV,QAAQ,OAAO,IAAI,CAAC,WAAW,EAAE,SAAS,MAAM,KAAK,GAAG,WAAW,QAAQ,iBAAiB,OAAO,EAAE;AAAA,cACrG,YAAY,iBAAiB,OAAO,IAAI,kBAAkB,OAAO,IAAI;AAAA,cACrE,GAAI,mBAAmB,SAAS,KAAK,EAAE,UAAU,mBAAmB;AAAA,YACtE;AAAA,YACA;AAAA,cACE,UAAU;AAAA,cACV,MAAM,QAAQ,GAAG;AAAA,YACnB;AAAA,UACF;AAEA,kBAAQ,IAAI,cAAAA,QAAM,KAAK,gBAAgB,cAAc,WAAW,CAAC;AAEjE,cAAI,iBAAiB,OAAO,GAAG;AAE7B,kBAAM,SAAS,QAAQ,QAAQ,GAAG,WAAW,GAAG,IAAI,2BAA2B,GAAG,KAAK,KAAK,QAAQ,QAAQ,GAAG,KAAK;AAEpH,kBAAM;AAAA,cACJ;AAAA,cACA;AAAA,gBACE,UAAU,kBAAkB,OAAO;AAAA,gBACnC,QAAQ,KAAK,UAAU,QAAQ,MAAM,CAAC;AAAA,cACxC;AAAA,cACA;AAAA,YACF;AACA,oBAAQ,IAAI,cAAAA,QAAM,KAAK,gCAAgC,cAAc,GAAG,CAAC;AAAA,UAC3E;AAAA,QACF,OAAO;AAEL,kBAAQ,IAAI,cAAAA,QAAM,OAAO,iCAAiC,eAAe,OAAO,CAAC,KAAK,cAAc,GAAG,CAAC;AAAA,QAC1G;AAEA,YAAI,OAAQ,OAAM,KAAK,EAAE,IAAI,WAAW,SAAS,eAAe,CAAC;AACjE,YAAI,WAAY,UAAS,KAAK,EAAE,IAAI,WAAW,SAAS,eAAe,CAAC;AAAA,MAC1E;AAAA,IACF;AAGA,UAAM,yBAAyB,MAAM,WAAW,WAAW,QAAQ;AAEnE,YAAQ,IAAI,cAAAA,QAAM,KAAK,uBAAuB,SAAS,MAAM,OAAO,GAAG,CAAC;AAExE,QAAI,wBAAwB;AAC1B,wBAAkB,uBAAuB;AACzC,eAAS,uBAAuB,UAAW,CAAC;AAC5C,mBAAa,uBAAuB,cAAc;AAGlD,UAAI,uBAAuB,YAAY,SAAS;AAC9C,cAAM,eAAe,SAAS;AAC9B,gBAAQ,IAAI,cAAAA,QAAM,KAAK,mCAAmC,uBAAuB,OAAO,GAAG,CAAC;AAAA,MAC9F;AAGA,UAAI,uBAAuB,YAAY,SAAS;AAE9C,0BAAkB,uBAAuB;AACzC,gCAAwB,uBAAuB,kBAAkB,CAAC;AAClE,gBAAQ,uBAAuB,QAAQ,CAAC,GAAG,uBAAuB,OAAO,GAAG,KAAK,IAAI;AACrF,mBAAW,uBAAuB,WAAW,CAAC,GAAG,uBAAuB,UAAU,GAAG,QAAQ,IAAI;AACjG,qCAA6B,MAAM,gCAAgC,WAAW,OAAO;AAAA,MACvF;AAAA,IACF;AAEA,UAAM,WAAW,YAAAE,QAAK,SAAS,QAAQ,IAAI;AAE3C,UAAM;AAAA,MACJ;AAAA,QACE,IAAI;AAAA,QACJ,MAAM;AAAA,QACN;AAAA,QACA,SAASC,YAAkB,QAAQ;AAAA,QACnC,QAAQ,aAAa,IAAI,CAAC,SAAS,EAAE,SAAS,IAAI,KAAK,GAAG,WAAW,QAAQ,iBAAiB,OAAO,EAAE;AAAA,QACvG,UAAU;AAAA,QACV;AAAA,QACA;AAAA,QACA,YAAY,YAAY;AAAA,QACxB,gBAAgB;AAAA,UACd,GAAG;AAAA,UACH,cAAc,YAAY;AAAA,QAC5B;AAAA,QACA,GAAI,UAAU,EAAE,OAAO;AAAA,QACvB,GAAI,cAAc,EAAE,WAAW;AAAA,MACjC;AAAA,MACA;AAAA,QACE,UAAU;AAAA,MACZ;AAAA,IACF;AAGA,UAAM,YAAY;AAAA;AAAA,MAEhB,GAAG;AAAA,MACH;AAAA,QACE,SAAS,qBAAqB,kBAAkB,SAAS,QAAQ,IAAI,MAAM,eAAe,OAAO;AAAA,QACjG,UAAU,YAAAD,QAAK,SAAS,QAAQ,IAAI,KAAK;AAAA,MAC3C;AAAA,IACF;AAEA,eAAW,YAAY,WAAW;AAChC,YAAM;AAAA,QACJ;AAAA,QACA;AAAA,UACE,UAAU,SAAS;AAAA,UACnB,SAAS,SAAS;AAAA,QACpB;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,IAAI,cAAAF,QAAM,KAAK,gBAAgB,OAAO,WAAW,CAAC;AAE1D,YAAQ,IAAI,cAAAA,QAAM,MAAM;AAAA,iDAAoD,SAAS,MAAM,OAAO,GAAG,CAAC;AAAA,EACxG;AACF;AAEA,IAAM,oBAAoB,CAAC,SAAkB,aAAwC;AACnF,QAAM,iBAAiB,QAAQ,KAAK,SAAS,OAAO;AACpD,SAAO,iBACH,KAAK,UAAU,SAAS,KAAK,EAAE,SAAS,QAAQ,MAAM,CAAC,IACvD,eAAAI,QAAK,KAAK,SAAS,KAAK,EAAE,SAAS,QAAQ,EAAE,QAAQ,KAAK,CAAC;AACjE;AAEA,IAAM,iBAAiB,OAAO,YAAqB;AACjD,MAAI,QAAQ,KAAK,WAAW,MAAM,GAAG;AACnC,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,QAAQ,IAAI;AACzC,aAAO,SAAS,KAAK;AAAA,IACvB,SAAS,OAAO;AACd,cAAQ,IAAI,cAAAJ,QAAM,IAAI;AAAA,uCAA0C,QAAQ,IAAI,EAAE,CAAC;AAC/E,aAAO;AAAA,IACT;AAAA,EACF,OAAO;AACL,WAAO,UAAM,0BAAS,QAAQ,MAAM,MAAM;AAAA,EAC5C;AACF;AAUA,IAAM,wBAAwB,CAAC,YAAuC;AACpE,QAAM,QAAQ,QAAQ,WAAW,EAAE,IAAI,qBAAqB,GAAG,MAAM,KAAK;AAC1E,SAAO,UAAU;AACnB;","names":["import_chalk","defaultMarkdown","getSummary","defaultMarkdown","defaultMarkdown","chalk","argv","utils","chalk","defaultMarkdown","path","getSummary","yaml"]}